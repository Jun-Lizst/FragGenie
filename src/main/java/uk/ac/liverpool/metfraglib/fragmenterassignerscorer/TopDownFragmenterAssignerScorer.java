package uk.ac.liverpool.metfraglib.fragmenterassignerscorer;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.TreeSet;

import uk.ac.liverpool.metfraglib.fragment.Fragment;
import uk.ac.liverpool.metfraglib.fragment.FragmentWrapper;
import uk.ac.liverpool.metfraglib.fragmenter.Fragmenter;
import uk.ac.liverpool.metfraglib.precursor.Precursor;

public class TopDownFragmenterAssignerScorer {

	/**
	 * 
	 */
	private final Map<String, Byte> bitArrayToFragment = new HashMap<>();

	/**
	 * 
	 */
	private final boolean positiveMode = true;

	/**
	 * 
	 */
	private final int maximumTreeDepth = 2;

	/**
	 * 
	 */
	private final Precursor precursor;

	/**
	 * 
	 */
	private final Fragmenter fragmenter;

	/**
	 * 
	 * @param candidate
	 */
	public TopDownFragmenterAssignerScorer(final Precursor precursor) throws Exception {
		this.precursor = precursor;
		this.fragmenter = new Fragmenter(this.precursor);
	}

	/**
	 * 
	 * @return
	 * @throws Exception
	 */
	public double[] getMasses() throws Exception {
		final Set<Double> masses = new TreeSet<>();

		// generate root fragment to start fragmentation
		final Fragment root = this.precursor.toFragment();

		Queue<FragmentWrapper> toProcessFragments = new LinkedList<>();

		FragmentWrapper rootFragmentWrapper = new FragmentWrapper(root, Integer.valueOf(0));
		toProcessFragments.add(rootFragmentWrapper);

		/*
		 * iterate over the maximal allowed tree depth
		 */
		for (int k = 1; k <= this.maximumTreeDepth; k++) {
			java.util.Queue<FragmentWrapper> newToProcessFragments = new java.util.LinkedList<>();
			/*
			 * use each fragment that is marked as to be processed
			 */
			while (!toProcessFragments.isEmpty()) {
				/*
				 * generate fragments of new tree depth
				 */
				FragmentWrapper wrappedPrecursorFragment = toProcessFragments.poll();

				if (wrappedPrecursorFragment.getFragment().isDiscardedForFragmentation()) {
					Fragment clonedFragment = (Fragment) wrappedPrecursorFragment.getFragment().clone();
					clonedFragment.setAsDiscardedForFragmentation();
					if (0 < this.maximumTreeDepth)
						newToProcessFragments
								.add(new FragmentWrapper(clonedFragment, wrappedPrecursorFragment.getPeakIndex()));
					continue;
				}
				/*
				 * generate fragments of next tree depth
				 */
				java.util.ArrayList<Fragment> fragmentsOfCurrentTreeDepth = this.fragmenter
						.getFragmentsOfNextTreeDepth(wrappedPrecursorFragment.getFragment());

				/*
				 * get peak pointer of current precursor fragment
				 */
				int peakIndex = wrappedPrecursorFragment.getPeakIndex();
				/*
				 * start loop over all child fragments from precursor fragment to try assigning
				 * them to the current peak
				 */
				for (int l = 0; l < fragmentsOfCurrentTreeDepth.size(); l++) {
					Fragment currentFragment = fragmentsOfCurrentTreeDepth.get(l);

					if (!fragmentsOfCurrentTreeDepth.get(l).isValidFragment()) {
						if (0 < this.maximumTreeDepth)
							newToProcessFragments
									.add(new FragmentWrapper(fragmentsOfCurrentTreeDepth.get(l), peakIndex));
						continue;
					}
					/*
					 * needs to be set otherwise you get fragments generated by multiple cleavage in
					 * one chain
					 */

					if (this.wasAlreadyGeneratedByHashtable(currentFragment)) {
						currentFragment.setAsDiscardedForFragmentation();
						if (0 < this.maximumTreeDepth)
							newToProcessFragments.add(new FragmentWrapper(currentFragment, peakIndex));
						continue;
					}

					int tempPeakPointer = peakIndex;
					while (tempPeakPointer >= 0) {

						/*
						 * calculate match
						 */
						masses.addAll(currentFragment.getMasses(this.precursor, 2, this.positiveMode));

						/*
						 * if the mass of the current fragment was greater than the peak mass then
						 * assign the current peak ID to the peak IDs of the child fragments as they
						 * have smaller masses
						 */
						if (tempPeakPointer == 0) {
							/*
							 * mark current fragment for further fragmentation
							 */
							if (0 < this.maximumTreeDepth)
								newToProcessFragments.add(new FragmentWrapper(currentFragment, tempPeakPointer));
						}

						tempPeakPointer--;
					}
				}
			}
			toProcessFragments = newToProcessFragments;
		}

		final double[] massesArray = new double[masses.size()];
		int i = 0;

		for (Double mass : masses) {
			massesArray[i++] = mass.doubleValue();
		}

		return massesArray;
	}

	/**
	 * 
	 * @param currentFragment
	 * @return boolean
	 */
	private boolean wasAlreadyGeneratedByHashtable(final Fragment currentFragment) {
		final String currentHash = currentFragment.getAtomsFastBitArray().toString();
		final Byte minimalTreeDepth = this.bitArrayToFragment.get(currentHash);

		if (minimalTreeDepth == null) {
			this.bitArrayToFragment.put(currentHash, Byte.valueOf((byte) 0));
			return false;
		}

		if (minimalTreeDepth.intValue() >= 0) {
			return false;
		}

		return true;
	}
}